<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="JianMin-Xie的博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://jianmin-xie.github.io">
    <!--SEO-->

<meta name="keywords" content="NoSql数据库" />


<meta name="description" content="一、概述Redis 是 C 语言开发的一个开源的（遵从 BSD 协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。

性能优秀，数据在内存中，读写速度非常..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    Redis详解 |
    
    JianMin-Xie的博客
</title>

<link rel="alternate" href="/atom.xml" title="JianMin-Xie的博客" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 4.2.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    /img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='JianMin-Xie'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <h2>
                 
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://jianmin-xie.github.io">
                        JianMin-Xie的博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/数据结构与算法/"><i class="fa "></i>
                                数据结构与算法</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/Java/"><i class="fa "></i>
                                Java</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/计算机网络/"><i class="fa "></i>
                                计算机网络</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/操作系统/"><i class="fa "></i>
                                操作系统</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/数据库/"><i class="fa "></i>
                                数据库</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Redis详解">
            
            Redis详解
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/Redis/">Redis</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/NoSql%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">NoSql数据库</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2020/04/16</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Redis 是 C 语言开发的一个开源的（遵从 BSD 协议）高性能键值对（key-value）的内存数据库，可以用作<strong>数据库</strong>、<strong>缓存</strong>、<strong>消息中间件</strong>等。</p>
<ul>
<li>性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS。</li>
<li>单进程单线程，是线程安全的，采用 IO 多路复用机制。</li>
<li>丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。</li>
<li>支持数据持久化。</li>
<li>可以将内存中数据保存在磁盘中，重启时加载。</li>
<li>主从复制，哨兵，高可用。</li>
<li>可以用作分布式锁。</li>
<li>可以作为消息中间件使用，支持发布订阅。</li>
</ul>
<p><strong>redis内部内存管理</strong><br><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUeVgXnGcUJ4HicZ3ZJ0jmYX8EicuSadC66qAEeSOFO6ljUHdpPhBib3XSQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<p>首先 Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。</p>
<p>redisObject 最主要的信息如上图所示：type 表示一个 value 对象具体是何种数据类型，encoding 是不同数据类型在 Redis 内部的存储方式。</p>
<p>比如：type=string 表示 value 存储的是一个普通字符串，那么 encoding 可以是 raw 或者 int。</p>
<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUyCdWIFiaMefm72ic8v3l65epCc9hAWymHuNCmXIMk4knibKBSRl7U741g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String是 Redis 最基本的类型，可以理解成与 Memcached一模一样的类型，一个 Key 对应一个 Value。Value 不仅是 String，也可以是数字。  </p>
<p>String 类型是二进制安全的，意思是 Redis 的 String 类型可以包含任何数据，比如 jpg 图片或者序列化的对象。String 类型的值最大能存储 512M。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET runoob <span class="string">"菜鸟教程"</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GET runoob</span><br><span class="line"><span class="string">"菜鸟教程"</span></span><br></pre></td></tr></table></figure>
<p>在以上实例中我们使用了Redis 的 SET 和 GET 命令。键为 runoob，对应的值为 菜鸟教程。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash是一个键值（key-value）的集合。Redis 的 Hash 是一个 String 的 Key 和 Value 的映射表，Hash 特别适合存储对象。常用命令：hget，hset，hgetall 等。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET runoob field1 <span class="string">"Hello"</span> field2 <span class="string">"World"</span></span><br><span class="line"><span class="string">"OK"</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET runoob field1</span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET runoob field2</span><br><span class="line"><span class="string">"World"</span></span><br></pre></td></tr></table></figure>
<p>实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。</p>
<p>每个 hash 可以存储 232 -1 键值对（40多亿）。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边） 常用命令：lpush、rpush、lpop、rpop、lrange（获取列表片段）等。  </p>
<p>应用场景：List 应用场景非常多，也是 Redis 最重要的数据结构之一，比如 Twitter 的关注列表，粉丝列表都可以用 List 结构来实现。</p>
<p>数据结构：List 就是链表，可以用来当消息队列用。Redis 提供了 List 的 Push 和 Pop 操作，还提供了操作某一段的 API，可以直接查询或者删除某一段的元素。</p>
<p>实现方式：Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush runoob redis</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush runoob mongodb</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush runoob rabitmq</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">3</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange runoob <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"rabitmq"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 是 String 类型的无序集合。集合是通过 hashtable 实现的。Set 中的元素是没有顺序的，而且是没有重复的。常用命令：sdd、spop、smembers、sunion 等。</p>
<p>应用场景：Redis Set 对外提供的功能和 List 一样是一个列表，特殊之处在于 Set 是自动去重的，而且 Set 提供了判断某个成员是否在一个 Set 集合中。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd runoob redis</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd runoob mongodb</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd runoob rabitmq</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd runoob rabitmq</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers runoob</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) <span class="string">"redis"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"rabitmq"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"mongodb"</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p>
<p>集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>Zset 和 Set 一样是 String 类型元素的集合，且不允许重复的元素。常用命令：zadd、zrange、zrem、zcard 等。</p>
<p>使用场景：Sorted Set 可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd runoob <span class="number">0</span> redis</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd runoob <span class="number">0</span> mongodb</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd runoob <span class="number">0</span> rabitmq</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd runoob <span class="number">0</span> rabitmq</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; &gt; ZRANGEBYSCORE runoob <span class="number">0</span> <span class="number">1000</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"rabitmq"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure>

<h1 id="三、在实际项目中使用缓存有遇到什么问题或者会遇到什么问题"><a href="#三、在实际项目中使用缓存有遇到什么问题或者会遇到什么问题" class="headerlink" title="三、在实际项目中使用缓存有遇到什么问题或者会遇到什么问题?"></a>三、在实际项目中使用缓存有遇到什么问题或者会遇到什么问题?</h1><h2 id="缓存和数据库数据一致性问题"><a href="#缓存和数据库数据一致性问题" class="headerlink" title="缓存和数据库数据一致性问题"></a>缓存和数据库数据一致性问题</h2><p>分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。</p>
<p>我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。</p>
<p>合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。</p>
<h2 id="Redis-雪崩"><a href="#Redis-雪崩" class="headerlink" title="Redis 雪崩"></a>Redis 雪崩</h2><p>目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。</p>
<p>举个栗子：如果首页所有 Key 的失效时间都是 12 小时，中午 12 点刷新的，我零点有个大促活动大量用户涌入，假设每秒 6000 个请求，本来缓存可以抗住每秒 5000 个请求，但是缓存中所有 Key 都失效了。</p>
<p>此时 6000 个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能 DBA 都没反应过来直接挂了。</p>
<p>此时，如果没什么特别的方案来处理，DBA 很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。</p>
<p>想想如果挂的是一个用户服务的库，那其他依赖他的库所有接口几乎都会报错。</p>
<p>如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你重启好的时候，用户早睡觉去了，临睡之前，骂骂咧咧“什么垃圾产品”。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li>在批量往 Redis 存数据的时候，把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRedis（<span class="built_in">key</span>, value, <span class="built_in">time</span>+Math.<span class="built_in">random</span>()*<span class="number">10000</span>）;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 Redis 是集群部署，将热点数据均匀分布在不同的 Redis 库中也能避免全部失效。</li>
<li>设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就好了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。</li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求。</p>
<p>举个栗子：我们数据库的 id 都是从 1 自增的，如果发起 id=-1 的数据或者 id 特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库。</p>
<p><strong>解决方法</strong></p>
<ul>
<li>在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接 return，比如 id 做基础校验，id&lt;=0 直接拦截。</li>
<li>Redis 里有一个高级用法布隆过滤器（Bloom Filter）这个也能很好的预防缓存穿透的发生。利用高效的数据结构和算法快速判断出你这个 Key 是否在数据库中存在，不存在你 return 就好了，存在你就去查 DB 刷新 KV 再 return。</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指一个 Key 非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个 Key 在失效的瞬间，持续的大并发直接落到了数据库上，就在这个 Key 的点上击穿了缓存。</p>
<p><strong>解决方法</strong></p>
<ul>
<li>设置热点数据永不过期</li>
<li>加上互斥锁</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static String get<span class="constructor">Data(String <span class="params">key</span>)</span> throws InterruptedException &#123;</span><br><span class="line">    <span class="comment">//从Redis查询数据</span></span><br><span class="line">    String result = get<span class="constructor">DataByKV(<span class="params">key</span>)</span>;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">Blank(<span class="params">result</span>)</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得锁</span></span><br><span class="line">            <span class="keyword">if</span> (reenLock.<span class="keyword">try</span><span class="constructor">Lock()</span>) &#123;</span><br><span class="line">                <span class="comment">//去数据库查询</span></span><br><span class="line">                result = get<span class="constructor">DataByDB(<span class="params">key</span>)</span>;</span><br><span class="line">                <span class="comment">//校验</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">NotBlank(<span class="params">result</span>)</span>) &#123;</span><br><span class="line">                    <span class="comment">//插进缓存</span></span><br><span class="line">                    set<span class="constructor">DataToKV(<span class="params">key</span>, <span class="params">result</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//睡一会再拿</span></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">100L</span>);</span><br><span class="line">                result = get<span class="constructor">Data(<span class="params">key</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            reenLock.unlock<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、Redis-为何这么快"><a href="#四、Redis-为何这么快" class="headerlink" title="四、Redis 为何这么快"></a>四、Redis 为何这么快</h1><h2 id="Redis-这么快，为什么还是单线程"><a href="#Redis-这么快，为什么还是单线程" class="headerlink" title="Redis 这么快，为什么还是单线程?"></a>Redis 这么快，为什么还是单线程?</h2><p>因为 Redis 完全是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。</p>
<p>既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章的采用单线程的方案了</p>
<p><strong>具体来说：</strong></p>
<ul>
<li>Redis 完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度是 O(1)。</li>
<li>数据结构简单，对数据操作也简单。</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的 CPU 切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。</li>
<li>使用多路复用 IO 模型，非阻塞 IO。</li>
</ul>
<h1 id="五、Redis-和-Memcached-的区别"><a href="#五、Redis-和-Memcached-的区别" class="headerlink" title="五、Redis 和 Memcached 的区别"></a>五、Redis 和 Memcached 的区别</h1><p><strong>原因有如下四点：</strong></p>
<ul>
<li><strong>存储方式上</strong>：Memcache 会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部分数据存在硬盘上，这样能保证数据的持久性。</li>
<li><strong>数据支持类型上</strong>：Memcache 对数据类型的支持简单，只支持简单的 key-value，，而 Redis 支持五种数据类型</li>
<li><strong>使用底层模型不同</strong>：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
<li><strong>Value 的大小</strong>：Redis 可以达到 1GB，而 Memcache 只有 1MB。</li>
</ul>
<h1 id="六、淘汰策略"><a href="#六、淘汰策略" class="headerlink" title="六、淘汰策略"></a>六、淘汰策略</h1><p>六种淘汰策略，如下图：<br><img src="https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUKqZCfMpUucu4O27WVokpgaTu8icIugFNKXTveIs9I1EpXWKIa0BInAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<blockquote>
<p>补充一下：Redis 4.0 加入了 LFU（least frequency use）淘汰策略，包括 volatile-lfu 和 allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的 KV 淘汰。</p>
</blockquote>
<h1 id="七、持久化"><a href="#七、持久化" class="headerlink" title="七、持久化"></a>七、持久化</h1><p>Redis 为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。</p>
<h2 id="Redis-的持久化策略："><a href="#Redis-的持久化策略：" class="headerlink" title="Redis 的持久化策略："></a>Redis 的持久化策略：</h2><ul>
<li><p><strong>RDB</strong>：快照形式是直接把内存中的数据保存到一个 dump 的文件中，定时保存，保存策略。</p>
</li>
<li><p><strong>AOF</strong>：把所有的对 Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。Redis 默认是快照 RDB 的持久化方式。</p>
</li>
</ul>
<p>当 Redis 重启的时候，它会优先使用 AOF 文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存。</p>
<h2 id="RDB-是怎么工作的？"><a href="#RDB-是怎么工作的？" class="headerlink" title="RDB 是怎么工作的？"></a>RDB 是怎么工作的？</h2><p>默认 Redis 是会以快照”RDB”的形式将数据持久化到磁盘的一个二进制文件 dump.rdb。</p>
<p>工作原理简单说一下：当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到磁盘上一个临时 RDB 文件中。</p>
<p>当子进程完成写临时文件后，将原来的 RDB 替换掉，这样的好处是可以 copy-on-write。</p>
<p><strong>优点</strong>：  </p>
<p>这种文件非常适合用于备份：比如，你可以在最近的 24 小时内，每小时备份一次，并且在每个月的每一天也备份一个 RDB 文件。</p>
<p>这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适合灾难恢复。</p>
<p><strong>缺点</strong>：</p>
<p>如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。</p>
<h2 id="AOF-是怎么工作的？"><a href="#AOF-是怎么工作的？" class="headerlink" title="AOF 是怎么工作的？"></a>AOF 是怎么工作的？</h2><p>使用 AOF 做持久化，每一个写命令都通过 write 函数追加到 appendonly.aof 中，配置方式如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">appendfsync</span> <span class="literal">yes</span>   </span><br><span class="line">appendfsync always     <span class="comment">#每次有数据修改发生时都会写入AOF文件。</span></span><br><span class="line">appendfsync everysec   <span class="comment">#每秒钟同步一次，该策略为AOF的缺省策略。</span></span><br></pre></td></tr></table></figure>

<p>AOF 可以做到全程持久化，只需要在配置中开启 appendonly yes。这样 Redis 每执行一个修改数据的命令，都会把它添加到 AOF 文件中，当 Redis 重启时，将会读取 AOF 文件进行重放，恢复到 Redis 关闭前的最后时刻。</p>
<p><strong>优点</strong>：  </p>
<p>让 Redis 变得非常耐久。可以设置不同的 Fsync 策略，AOF的默认策略是每秒钟 Fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。</p>
<p><strong>缺点</strong>：</p>
<p>对于相同的数据集来说，AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 Fsync 策略，AOF 的速度可能会慢于 RDB。</p>
<h2 id="说了这么多，那我该用哪一个呢？"><a href="#说了这么多，那我该用哪一个呢？" class="headerlink" title="说了这么多，那我该用哪一个呢？"></a>说了这么多，那我该用哪一个呢？</h2><p>如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用 RDB 持久。</p>
<p>AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。</p>
<p>数据库备份和灾难恢复：定时生成 RDB 快照非常便于进行数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度快。</p>
<p>当然了，Redis 支持同时开启 RDB 和 AOF，系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。</p>
<h1 id="七、主从复制"><a href="#七、主从复制" class="headerlink" title="七、主从复制"></a>七、主从复制</h1><p>Redis 单节点存在单点故障问题，为了解决单点问题，一般都需要对 Redis 配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能。</p>
<h2 id="Redis-主从复制的过程和原理"><a href="#Redis-主从复制的过程和原理" class="headerlink" title="Redis 主从复制的过程和原理"></a>Redis 主从复制的过程和原理</h2><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><ul>
<li>从节点执行 slaveof[masterIP][masterPort]，保存主节点信息。</li>
<li>从节点中的定时任务发现主节点信息，建立和主节点的 Socket 连接。</li>
<li>从节点发送 Ping 信号，主节点返回 Pong，两边能互相通信。</li>
<li>连接建立后，主节点将所有数据发送给从节点（数据同步）。</li>
<li>主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</li>
</ul>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>Redis 2.8 之前使用 sync[runId][offset] 同步命令，Redis 2.8 之后使用 psync[runId][offset] 命令。</p>
<p>两者不同在于，Sync 命令仅支持全量复制过程，Psync 支持全量和部分复制。</p>
<p>介绍同步之前，先介绍几个概念：</p>
<ul>
<li><strong>runId</strong>：每个 Redis 节点启动都会生成唯一的 uuid，每次 Redis 重启后，runId 都会发生变化。</li>
<li><strong>offset</strong>：主节点和从节点都各自维护自己的主从复制偏移量 offset，当主节点有写入命令时，offset=offset+命令的字节长度。<br>从节点在收到主节点发送的命令后，也会增加自己的 offset，并把自己的 offset 发送给主节点。<br>这样，主节点同时保存自己的 offset 和从节点的 offset，通过对比 offset 来判断主从节点数据是否一致。</li>
<li><strong>repl_backlog_size</strong>：保存在主节点上的一个固定长度的先进先出队列，默认大小是 1MB。</li>
</ul>
<p>主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。</p>
<p>从节点同步主节点数据完成后，主节点将缓冲区的数据继续发送给从节点，用于部分复制。</p>
<p>主节点响应写命令时，不但会把命名发送给从节点，还会写入复制积压缓冲区，用于复制命令丢失的数据补救。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUAnSBz8bwrMlJWXKcRBLjQJM4k3sarlPKZZSYW3slicx0gYk35Em9R0A/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<p>上面是 Psync 的执行流程，从节点发送 psync[runId][offset] 命令，主节点有三种响应：</p>
<ul>
<li><p><strong>FULLRESYNC</strong>：第一次连接，进行全量复制</p>
</li>
<li><p><strong>CONTINUE</strong>：进行部分复制</p>
</li>
<li><p><strong>ERR</strong>：不支持 psync 命令，进行全量复制</p>
</li>
</ul>
<h3 id="全量复制的过程"><a href="#全量复制的过程" class="headerlink" title="全量复制的过程"></a>全量复制的过程</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GU5MNickDsx0y2md2KUCiapIkJt601zPiaxfDM5p9TYfVe2gziaF3zKQ5cyw/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<p>上面是全量复制的流程。主要有以下几步：</p>
<ul>
<li>从节点发送 psync ? -1 命令（因为第一次发送，不知道主节点的 runId，所以为?，因为是第一次复制，所以 offset=-1）。</li>
<li>主节点发现从节点是第一次复制，返回 FULLRESYNC {runId} {offset}，runId 是主节点的 runId，offset 是主节点目前的 offset。</li>
<li>从节点接收主节点信息后，保存到 info 中。</li>
<li>主节点在发送 FULLRESYNC 后，启动 bgsave 命令，生成 RDB 文件（数据持久化）。</li>
<li>主节点发送 RDB 文件给从节点。到从节点加载数据完成这段期间主节点的写命令放入缓冲区。</li>
<li>从节点清理自己的数据库数据。</li>
<li>从节点加载 RDB 文件，将数据保存到自己的数据库中。如果从节点开启了 AOF，从节点会异步重写 AOF 文件。</li>
</ul>
<h3 id="部分复制的过程"><a href="#部分复制的过程" class="headerlink" title="部分复制的过程"></a>部分复制的过程</h3><ol>
<li><p>部分复制主要是 Redis 针对全量复制的过高开销做出的一种优化措施，使用 psync[runId][offset] 命令实现。<br>当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，主节点的复制积压缓冲区将这部分数据直接发送给从节点。<br>这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据。</p>
</li>
<li><p>主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制积压缓冲区依然可以保存最近一段时间的写命令数据。</p>
</li>
<li><p>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行 ID。因此会把它们当做 psync 参数发送给主节点，要求进行部分复制。</p>
</li>
<li><p>主节点接收到 psync 命令后首先核对参数 runId 是否与自身一致，如果一致，说明之前复制的是当前主节点。<br>之后根据参数 offset 在复制积压缓冲区中查找，如果 offset 之后的数据存在，则对从节点发送+COUTINUE 命令，表示可以进行部分复制。因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制。</p>
</li>
<li><p>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</p>
</li>
</ol>
<h2 id="主从复制会存在哪些问题？"><a href="#主从复制会存在哪些问题？" class="headerlink" title="主从复制会存在哪些问题？"></a>主从复制会存在哪些问题？</h2><ul>
<li>一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</li>
<li>主节点的写能力受到单机的限制。</li>
<li>主节点的存储能力受到单机的限制。</li>
<li>原生复制的弊端在早期的版本中也会比较突出，比如：Redis 复制中断后，从节点会发起 psync。</li>
<li>此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</li>
</ul>
<h3 id="解决方案-哨兵。哨兵有哪些功能？"><a href="#解决方案-哨兵。哨兵有哪些功能？" class="headerlink" title="解决方案-哨兵。哨兵有哪些功能？"></a>解决方案-哨兵。哨兵有哪些功能？</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUZiaZZtRlHCfZEiaJWuUo3FuDJ83OGcZdxrufaXvZLrwXTSj8F8r5F2nQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<p>如图，是 Redis Sentinel（哨兵）的架构图。Redis Sentinel（哨兵）主要功能包括<strong>主节点存活检测、主从运行情况检测、自动故障转移、主从切换</strong>。</p>
<p>该系统可以执行以下四个任务：</p>
<ul>
<li><p><strong>监控</strong>：不断检查主服务器和从服务器是否正常运行。</p>
</li>
<li><p><strong>通知</strong>：当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本向管理员或者其他应用程序发出通知。</p>
</li>
<li><p><strong>自动故障转移</strong>：当主节点不能正常工作时，Sentinel 会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。</p>
</li>
<li><p><strong>配置提供者</strong>：在 Redis Sentinel 模式下，客户端应用在初始化时连接的是 Sentinel 节点集合，从中获取主节点的信息。</p>
</li>
</ul>
<h3 id="哨兵的工作原理"><a href="#哨兵的工作原理" class="headerlink" title="哨兵的工作原理"></a>哨兵的工作原理</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUAl6zH9xDVB3kdJKTGsTOkXwmTxWXsu5H6kbdZ7YRicIXSmbcXAqrxXA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<ol>
<li>每个 Sentinel 节点都需要定期执行以下任务：每个 Sentinel 以每秒一次的频率，向它所知的主服务器、从服务器以及其他的 Sentinel 实例发送一个 PING 命令。（如上图）</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUuDnOTNFT8cicAf6iaBm4sB4MkJGJgxTqTnYnZoIYM3auo9NHhsuSPsPA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<ol start="2">
<li>如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel 标记为主观下线。（如上图）</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GU1vHpLmCTZX0wQGsVppaWQo3NKtbmtI0lfQnicTFmsuSfdDpeaWYg0KA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<ol start="3">
<li>如果一个主服务器被标记为主观下线，那么正在监视这个服务器的所有 Sentinel 节点，要以每秒一次的频率确认主服务器的确进入了主观下线状态。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUnpviaiaNfcIx8SOPbyoq3ykOXiaFKl0NVM0PTkMMOEoxZ3Z0NtfAuSQZw/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<ol start="4">
<li>如果一个主服务器被标记为主观下线，并且有足够数量的 Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUlGDrBs9vNNb50LVdHj5VkcLIPBdh4N6XSraZKGjkP10kemPJvLOrtA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<ol start="5">
<li>一般情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。</li>
</ol>
<p>当一个主服务器被标记为客观下线时，Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率，会从 10 秒一次改为每秒一次。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUo2GQ7ek1ibQQ3xAW36KXv0g0jodNG3e5UMR8jedceHH1TB5r4Nu9ialw/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<ol start="6">
<li>Sentinel 和其他 Sentinel 协商客观下线的主节点的状态，如果处于 SDOWN 状态，则投票自动选出新的主节点，将剩余从节点指向新的主节点进行数据复制。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhqawVia4Al9NLKSmdc3720GUyH9T17GuZSYNH1TPvtErBfq6DZZtMTWwgaqHn98WkNwmN2dd1WMqQw/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<ol start="7">
<li>当没有足够数量的 Sentinel 同意主服务器下线时，主服务器的客观下线状态就会被移除。<br>当主服务器重新向 Sentinel 的 PING 命令返回有效回复时，主服务器的主观下线状态就会被移除。</li>
</ol>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">JianMin-Xie</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    
    <a href="/2020/04/14/HashMap%E8%AF%A6%E8%A7%A3/" class="next-post btn btn-default" title='HashMap详解'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            HashMap详解</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMzA1MS85NjEz">
    <script type="text/javascript">
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
    </script>
</div>

</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、概述"><span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、数据类型"><span class="toc-text">二、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash"><span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-text">List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zset"><span class="toc-text">Zset</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、在实际项目中使用缓存有遇到什么问题或者会遇到什么问题"><span class="toc-text">三、在实际项目中使用缓存有遇到什么问题或者会遇到什么问题?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存和数据库数据一致性问题"><span class="toc-text">缓存和数据库数据一致性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-雪崩"><span class="toc-text">Redis 雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存穿透"><span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存击穿"><span class="toc-text">缓存击穿</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、Redis-为何这么快"><span class="toc-text">四、Redis 为何这么快</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-这么快，为什么还是单线程"><span class="toc-text">Redis 这么快，为什么还是单线程?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、Redis-和-Memcached-的区别"><span class="toc-text">五、Redis 和 Memcached 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、淘汰策略"><span class="toc-text">六、淘汰策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、持久化"><span class="toc-text">七、持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-的持久化策略："><span class="toc-text">Redis 的持久化策略：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB-是怎么工作的？"><span class="toc-text">RDB 是怎么工作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-是怎么工作的？"><span class="toc-text">AOF 是怎么工作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#说了这么多，那我该用哪一个呢？"><span class="toc-text">说了这么多，那我该用哪一个呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、主从复制"><span class="toc-text">七、主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-主从复制的过程和原理"><span class="toc-text">Redis 主从复制的过程和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复制过程"><span class="toc-text">复制过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据同步"><span class="toc-text">数据同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全量复制的过程"><span class="toc-text">全量复制的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#部分复制的过程"><span class="toc-text">部分复制的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主从复制会存在哪些问题？"><span class="toc-text">主从复制会存在哪些问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方案-哨兵。哨兵有哪些功能？"><span class="toc-text">解决方案-哨兵。哨兵有哪些功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哨兵的工作原理"><span class="toc-text">哨兵的工作原理</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>