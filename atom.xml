<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JianMin-Xie的博客</title>
  <icon>https://www.gravatar.com/avatar/a92ada1fe196269fac3b83d6d401ca7c</icon>
  <subtitle>有道无术，术尚可求。有术无道，止于术。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jianmin-xie.github.io/"/>
  <updated>2020-03-11T12:42:50.725Z</updated>
  <id>https://jianmin-xie.github.io/</id>
  
  <author>
    <name>JianMin-Xie</name>
    <email>854377742@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库之并发一致性问题</title>
    <link href="https://jianmin-xie.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://jianmin-xie.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-11T12:42:15.000Z</published>
    <updated>2020-03-11T12:42:50.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。<br><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png" alt=""></p><h2 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h2><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。<br><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png" alt=""></p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。<br><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png" alt=""></p><h2 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h2><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。<br><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png" alt=""></p><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发一致性问题&quot;&gt;&lt;a href=&quot;#并发一致性问题&quot; class=&quot;headerlink&quot; title=&quot;并发一致性问题&quot;&gt;&lt;/a&gt;并发一致性问题&lt;/h1&gt;&lt;p&gt;在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。&lt;/p&gt;
&lt;h2 id=&quot;丢失修改
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://jianmin-xie.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://jianmin-xie.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>一、算法-选择排序与冒泡排序</title>
    <link href="https://jianmin-xie.github.io/2020/03/11/%E4%B8%80%E3%80%81%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://jianmin-xie.github.io/2020/03/11/%E4%B8%80%E3%80%81%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2020-03-11T12:36:15.000Z</published>
    <updated>2020-03-11T12:36:12.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法，可以用它来判断两个元素的大小关系。</p><p>使用辅助函数 less() 和 swap() 来进行比较和交换的操作，使得代码的可读性和可移植性更好。</p><p>排序算法的成本模型是比较和交换的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(T v, T w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        T t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p><p>选择排序需要 ~N2/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bc6be2d0-ed5e-4def-89e5-3ada9afa811a.gif" alt=""></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Selection&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span> <span class="keyword">extends</span> <span class="title">Sort&lt;T&gt;</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void sort(<span class="type">T</span>[] nums) &#123;</span><br><span class="line">        int <span class="type">N</span> = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="type">N</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            int min = i;</span><br><span class="line">            <span class="keyword">for</span> (int j = i + <span class="number">1</span>; j &lt; <span class="type">N</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(nums[j], nums[min])) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p><p>在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0f8d178b-52d8-491b-9dfd-41e05a952578.gif" alt=""></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Bubble&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span> <span class="keyword">extends</span> <span class="title">Sort&lt;T&gt;</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void sort(<span class="type">T</span>[] nums) &#123;</span><br><span class="line">        int <span class="type">N</span> = nums.length;</span><br><span class="line">        boolean isSorted = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="type">N</span> - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; !isSorted; i--) &#123;</span><br><span class="line">            isSorted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(nums[j + <span class="number">1</span>], nums[j])) &#123;</span><br><span class="line">                    isSorted = <span class="literal">false</span>;</span><br><span class="line">                    swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;约定&quot;&gt;&lt;a href=&quot;#约定&quot; class=&quot;headerlink&quot; title=&quot;约定&quot;&gt;&lt;/a&gt;约定&lt;/h2&gt;&lt;p&gt;待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法，可以用它来判断两个元素的大小关系。&lt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://jianmin-xie.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://jianmin-xie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二、计算机网络之物理层</title>
    <link href="https://jianmin-xie.github.io/2020/03/11/%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://jianmin-xie.github.io/2020/03/11/%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2020-03-10T18:09:15.000Z</published>
    <updated>2020-03-10T18:11:19.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h2 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h2><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c34f4503-f62c-4043-9dc6-3e03288657df.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通信方式&quot;&gt;&lt;a href=&quot;#通信方式&quot; class=&quot;headerlink&quot; title=&quot;通信方式&quot;&gt;&lt;/a&gt;通信方式&lt;/h2&gt;&lt;p&gt;根据信息在传输线上的传送方向，分为以下三种通信方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单工通信：单向传输&lt;/li&gt;
&lt;li&gt;半双工
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://jianmin-xie.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://jianmin-xie.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>一、计算机网络之概述</title>
    <link href="https://jianmin-xie.github.io/2020/03/11/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
    <id>https://jianmin-xie.github.io/2020/03/11/%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0/</id>
    <published>2020-03-10T17:59:15.000Z</published>
    <updated>2020-03-10T18:06:15.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/network-of-networks.gif" alt=""></p><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72be01cd-41ae-45f7-99b9-a8d284e44dd4.png" alt=""></p><p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3be42601-9d33-4d29-8358-a9d16453af93.png" alt=""></p><h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><ul><li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" alt=""></p><ul><li>对等（P2P）：不区分客户和服务器。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" alt=""></p><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1. 电路交换"></a>1. 电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p><h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2. 分组交换"></a>2. 分组交换</h3><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p><p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg" alt=""></p><h3 id="1-排队时延"><a href="#1-排队时延" class="headerlink" title="1. 排队时延"></a>1. 排队时延</h3><p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p><h3 id="2-处理时延"><a href="#2-处理时延" class="headerlink" title="2. 处理时延"></a>2. 处理时延</h3><p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p><h3 id="3-传输时延"><a href="#3-传输时延" class="headerlink" title="3. 传输时延"></a>3. 传输时延</h3><p>主机或路由器传输数据帧所需要的时间。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dcdbb96c-9077-4121-aeb8-743e54ac02a4.png" alt=""></p><p>其中 l 表示数据帧的长度，v 表示传输速率。</p><h3 id="4-传播时延"><a href="#4-传播时延" class="headerlink" title="4. 传播时延"></a>4. 传播时延</h3><p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a1616dac-0e12-40b2-827d-9e3f7f0b940d.png" alt=""></p><p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" alt=""></p><h3 id="1-五层协议"><a href="#1-五层协议" class="headerlink" title="1. 五层协议"></a>1. 五层协议</h3><ul><li><p><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p></li><li><p><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p></li><li><p><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</p></li><li><p><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p></li><li><p><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p></li></ul><h3 id="2-OSI"><a href="#2-OSI" class="headerlink" title="2. OSI"></a>2. OSI</h3><p>其中表示层和会话层用途如下：</p><ul><li><p><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p></li><li><p><strong>会话层</strong> ：建立及管理会话。</p></li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="3-TCP-IP"><a href="#3-TCP-IP" class="headerlink" title="3. TCP/IP"></a>3. TCP/IP</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" alt=""></p><h3 id="4-数据在各层之间的传递过程"><a href="#4-数据在各层之间的传递过程" class="headerlink" title="4. 数据在各层之间的传递过程"></a>4. 数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络的网络&quot;&gt;&lt;a href=&quot;#网络的网络&quot; class=&quot;headerlink&quot; title=&quot;网络的网络&quot;&gt;&lt;/a&gt;网络的网络&lt;/h2&gt;&lt;p&gt;网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Int
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://jianmin-xie.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://jianmin-xie.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>提高开发效率必备工具lombok</title>
    <link href="https://jianmin-xie.github.io/2020/03/10/%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7lombok/"/>
    <id>https://jianmin-xie.github.io/2020/03/10/%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7lombok/</id>
    <published>2020-03-09T16:45:15.000Z</published>
    <updated>2020-03-10T17:55:34.022Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>PS:免费章节转载注明出处，本篇如果是收费章节禁止转载。违者必究。<br>作者：字母哥博客<br>本文出自：springboot深入浅出系列</p></blockquote><h2 id="一、前置说明"><a href="#一、前置说明" class="headerlink" title="一、前置说明"></a>一、前置说明</h2><h3 id="本节大纲"><a href="#本节大纲" class="headerlink" title="本节大纲"></a>本节大纲</h3><ul><li><p>使用lombok插件的好处</p></li><li><p>如何安装lombok插件</p></li><li><p>使用lombok提高开发效率</p><h2 id="二、使用lombok插件的好处"><a href="#二、使用lombok插件的好处" class="headerlink" title="二、使用lombok插件的好处"></a>二、使用lombok插件的好处</h2><p>我们在java开发过程中，经常会有一些常规性的，重复性的工作。比如：</p></li><li><p>根据成员变量生成get和set方法</p></li><li><p>根据成员变量生成类的构造函数</p></li><li><p>重写toString()和hashCode方法</p></li><li><p>引入日志框架logFactory，用来打印日志<br>以上都是一些重复动作，模板代码。每次都手动生成既浪费时间，又增加了大量的冗余代码。我们可以使用lombok插件来解决这个问题。使我们的编码效率得到大幅度的提高！</p></li></ul><h2 id="三、如何安装lombok插件"><a href="#三、如何安装lombok插件" class="headerlink" title="三、如何安装lombok插件"></a>三、如何安装lombok插件</h2><p>笔者以InelliJ IDEA为例，安装lombok插件。打开 IDEA 的 File-&gt;Settings 面板，并选择 Plugins 选项，然后点击 “Browse repositories”。在搜索框输入”lombok”，结果中找到lombok点击install，然后重启 IDEA。</p><p><img src="https://img.kancloud.cn/45/d4/45d483570ca6807eae7de5e6c3ab3cd6_762x511.png" alt=""></p><p>我们还要在pom.xml里面加上如下依赖，插件生效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在Spring Boot项目里面不需要加入版本号，spring Boot父项目会代为管理。如果是其他项目，请自行添加版本号！</p></blockquote><h2 id="四、-使用lombok注解简化开发"><a href="#四、-使用lombok注解简化开发" class="headerlink" title="四、 使用lombok注解简化开发"></a>四、 使用lombok注解简化开发</h2><h3 id="4-1-Data注解"><a href="#4-1-Data注解" class="headerlink" title="4.1 Data注解"></a>4.1 Data注解</h3><p>在java类上使用@Data注解，将为我们在编译期自动生成</p><ul><li>成员变量的get和set方法</li><li>equals方法</li><li>canEqual方法</li><li>hashCode方法</li><li>toString方法</li></ul><p><img src="https://img.kancloud.cn/ab/0a/ab0a2c82558587327f06cca3f094d964_763x473.png" alt=""></p><p>上图左侧是使用lombok注解Data，右侧是java字节码class文件反编译结果</p><h3 id="4-2-Slf4j注解"><a href="#4-2-Slf4j注解" class="headerlink" title="4.2 Slf4j注解"></a>4.2 Slf4j注解</h3><p>将在编译期自动帮我们引入Logger日志常量，我们在代码中就直接使用log.info或log.debug打印日志即可。下图中红色代码就用Slf4j注解代替就可以了。</p><p><img src="https://img.kancloud.cn/d2/4f/d24f55de1112606f804e9bf6280b3be0_750x441.png" alt=""></p><h3 id="4-3-Builder注解"><a href="#4-3-Builder注解" class="headerlink" title="4.3 Builder注解"></a>4.3 Builder注解</h3><p>在Java类上使用Builder注解之后，我们可以使用如下代码为对象属性赋值</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LombokPOJO lombokPOJO = LombokPOJO<span class="number">.</span>builder()</span><br><span class="line"><span class="meta">        .name</span>(<span class="string">"kobe"</span>)</span><br><span class="line"><span class="meta">        .age</span>(<span class="number">39</span>)</span><br><span class="line"><span class="meta">        .build</span>()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.kancloud.cn/bd/a3/bda328a18d6acb36be7a3673f2f4122c_1384x862.png" alt=""></p><h3 id="4-4-AllArgsConstructor注解"><a href="#4-4-AllArgsConstructor注解" class="headerlink" title="4.4 AllArgsConstructor注解"></a>4.4 AllArgsConstructor注解</h3><p>AllArgsConstructor注解将为我们在编译期自动生成：全参构造函数。</p><p><img src="https://img.kancloud.cn/f9/4f/f94f6763804e87144618e7c9cde0fd5a_1202x466.png" alt=""></p><p>有全参构造函数注解，自然就有无参构造函数注解：NoArgsConstructor注解。</p><p>lombok有非常多的好用的注解，这里给大家集中介绍几个经常会用到的。更多的用法参考github（插件安装图中，有github连接,上图中黄色区域）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;PS:免费章节转载注明出处，本篇如果是收费章节禁止转载。违者必究。&lt;br&gt;作者：字母哥博客&lt;br&gt;本文出自：springboot深入浅出系列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、前置说明&quot;&gt;&lt;a href=&quot;#一、前置说明&quot; c
      
    
    </summary>
    
    
      <category term="Java" scheme="https://jianmin-xie.github.io/categories/Java/"/>
    
    
      <category term="lombok" scheme="https://jianmin-xie.github.io/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>什么是Vue</title>
    <link href="https://jianmin-xie.github.io/2020/03/10/%E4%BB%80%E4%B9%88%E6%98%AFVue/"/>
    <id>https://jianmin-xie.github.io/2020/03/10/%E4%BB%80%E4%B9%88%E6%98%AFVue/</id>
    <published>2020-03-09T16:40:15.000Z</published>
    <updated>2020-03-10T17:55:30.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-简介"><a href="#Vue-简介" class="headerlink" title="Vue 简介"></a>Vue 简介</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的<strong>渐进式框架</strong>，发布于 2014 年 2 月。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。<strong>Vue 的核心库只关注视图层</strong>，不仅易于上手，还便于与第三方库（如：<strong>vue-router，<del>vue-resource</del>，vuex</strong>）或既有项目整合。</p><p><a href="http://www.qfdmy.com/wp-content/themes/quanbaike/go.php?url=aHR0cHM6Ly9jbi52dWVqcy5vcmcv" target="_blank" rel="noopener">官方网站</a></p><h1 id="MVVM-模式的实现者"><a href="#MVVM-模式的实现者" class="headerlink" title="MVVM 模式的实现者"></a>MVVM 模式的实现者</h1><p>我们知道 MVVM 表示如下：</p><ul><li>Model：模型层，在这里表示 JavaScript 对象</li><li>View：视图层，在这里表示 DOM（HTML 操作的元素）</li><li>ViewModel：连接视图和数据的中间件，Vue.js 就是 MVVM 中的 ViewModel 层的实现者</li></ul><p><img src="http://www.qfdmy.com/wp-content/uploads/2019/08/65dff7b6ba81f8f.png" alt=""></p><p>在 MVVM 架构中，是不允许 <strong>数据</strong> 和 <strong>视图</strong> 直接通信的，只能通过 <strong>ViewModel</strong> 来通信，而 ViewModel 就是定义了一个 <strong>Observer</strong> 观察者</p><ul><li>ViewModel 能够观察到数据的变化，并对视图对应的内容进行更新</li><li>ViewModel 能够监听到视图的变化，并能够通知数据发生改变</li></ul><p>至此，我们就明白了，Vue.js 就是一个 MVVM 的实现者，他的核心就是实现了 <strong>DOM 监听</strong> 与 <strong>数据绑定</strong></p><h1 id="其它-MVVM-实现者"><a href="#其它-MVVM-实现者" class="headerlink" title="其它 MVVM 实现者"></a>其它 MVVM 实现者</h1><ul><li>AngularJS</li><li>ReactJS</li><li>微信小程序</li></ul><h1 id="为什么要使用-Vue-js"><a href="#为什么要使用-Vue-js" class="headerlink" title="为什么要使用 Vue.js"></a>为什么要使用 Vue.js</h1><ul><li>轻量级，体积小是一个重要指标。Vue.js 压缩后有只有 20多kb （Angular 压缩后 56kb+，React 压缩后 44kb+）</li><li>移动优先。更适合移动端，比如移动端的 Touch 事件</li><li>易上手，学习曲线平稳，文档齐全</li><li>吸取了 Angular（模块化）和 React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属性</li><li>开源，社区活跃度高</li></ul><h1 id="Vue-js-的两大核心要素"><a href="#Vue-js-的两大核心要素" class="headerlink" title="Vue.js 的两大核心要素"></a>Vue.js 的两大核心要素</h1><h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><p><img src="http://www.qfdmy.com/wp-content/uploads/2019/08/49933f4eeb6c704.png" alt=""></p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><ul><li>页面上每个独立的可交互的区域视为一个组件</li><li>每个组件对应一个工程目录，组件所需的各种资源在这个目录下就近维护</li><li>页面不过是组件的容器，组件可以嵌套自由组合（复用）形成完整的页面</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue-简介&quot;&gt;&lt;a href=&quot;#Vue-简介&quot; class=&quot;headerlink&quot; title=&quot;Vue 简介&quot;&gt;&lt;/a&gt;Vue 简介&lt;/h1&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://jianmin-xie.github.io/categories/Java/"/>
    
    
      <category term="Vue" scheme="https://jianmin-xie.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Feign的一种简单使用方式</title>
    <link href="https://jianmin-xie.github.io/2020/03/10/Spring-Cloud-Feign%E7%9A%84%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://jianmin-xie.github.io/2020/03/10/Spring-Cloud-Feign%E7%9A%84%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2020-03-09T16:24:15.000Z</published>
    <updated>2020-03-10T17:55:27.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近学习Spring Cloud Feign让我记忆颇深。本文记录一下声明式客户端 Feign的一种简单使用姿势。</p><h2 id="创建nacos注册中心"><a href="#创建nacos注册中心" class="headerlink" title="创建nacos注册中心"></a>创建nacos注册中心</h2><p>创建注册中心具体流程笔者略过。</p><p>启动浏览器访问你的注册中心。</p><p><img src="https://i.loli.net/2020/03/09/xHb8L3aOzKsjMpG.png" alt="1.png"></p><p>此时还没有任何服务注册上来。</p><h2 id="创建服务提供者"><a href="#创建服务提供者" class="headerlink" title="创建服务提供者"></a>创建服务提供者</h2><ul><li><p><strong>建工程</strong><br>创建一个名为 <code>provider</code>的 SpringBoot工程，并在pom.xml中添加好对应依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>改主类</strong><br>添加 <code>@EnableDiscoveryClient</code>注解</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@EnableDiscoveryClient</span></span><br><span class="line">public class ProviderApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(ProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加控制器</strong> <code>DateServiceController</code></p></li></ul><p>提供一个Restful接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> EchoController &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/echo/&#123;string&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> echo(<span class="meta">@PathVariable</span> <span class="built_in">String</span> <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Nacos Provider "</span> + <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置 <code>application.yml</code>文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 服务名</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># 你的注册中心地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.102</span><span class="number">.133</span><span class="string">:8848</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8070</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><ul><li><strong>启动工程</strong></li></ul><p>浏览器访问服务注册中心，我们发现服务提供者 <code>provider</code>已经注册到 nacos注册中心上：</p><p><img src="https://i.loli.net/2020/03/09/Nu59ItQ78yoUnH3.png" alt="2.png"></p><p>同时浏览器访问：<code>http://localhost:8070/echo/今天天气真好</code>，可以测试服务提供 <code>provider</code>提供的接口工作正常</p><p><img src="https://i.loli.net/2020/03/09/4VLHp1ju8RdD5fq.jpg" alt="3.JPG"></p><blockquote><p>测试发现服务提供者的接口工作正常</p></blockquote><p>接下来我们创建服务消费者，是 Feign该登场的时候了！</p><h2 id="创建基于-Feign的服务消费者"><a href="#创建基于-Feign的服务消费者" class="headerlink" title="创建基于 Feign的服务消费者"></a>创建基于 Feign的服务消费者</h2><ul><li>创建一个名为 <code>consumer</code>的 SpringBoot工程，并在pom.xml中添加好对应依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot Begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring Boot End --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring Cloud Begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring Cloud End --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>修改应用主类</strong><br>主要是添加有关 Feign客户端的一些注解</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@EnableFeignClients</span></span><br><span class="line"><span class="variable">@EnableDiscoveryClient</span></span><br><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line">public class ConsumerApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>创建一个 Feign客户端的接口</strong>：<code>EchoService</code></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(value = <span class="string">"provider"</span>)</span><br><span class="line">public interface EchoService &#123;</span><br><span class="line">    <span class="variable">@GetMapping</span>(value = <span class="string">"/echo/&#123;string&#125;"</span>)</span><br><span class="line">    String echo(<span class="variable">@PathVariable</span>(<span class="string">"string"</span>) String string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显其内部用 <code>@FeignClient( value = &quot;provider&quot; )</code> 声明的方式指向了 服务提供者，而接口方法则实现了对 服务提供者接口的实际调用</p><ul><li><strong>创建控制器</strong>：<code>TestEchoController</code> 注意，这是服务消费者提供的 Rest接口</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@RestController</span></span><br><span class="line">public class TestEchoController &#123;</span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private EchoService echoService;</span><br><span class="line">    <span class="variable">@GetMapping</span>(value = <span class="string">"/feign/echo/&#123;str&#125;"</span>)</span><br><span class="line">    public String echo(<span class="variable">@PathVariable</span> String str) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">echoService</span><span class="selector-class">.echo</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>配置</strong> <code>application.yml</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 服务名</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># 服务注册中心</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.102</span><span class="number">.133</span><span class="string">:8848</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment"># 服务端口</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="comment"># 端点检查（健康检查）</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><ul><li><strong>启动服务消费者</strong></li></ul><p>我们先去服务注册中心上看看，发现 服务消费者也注册上来了：</p><p><img src="https://i.loli.net/2020/03/09/EqAfPxzVmnhTbge.jpg" alt="4.JPG"></p><p>然后我们浏览器访问 服务消费者提供的Rest接口： <code>http://localhost:8080/feign/echo/今天天气不好</code></p><p><img src="https://i.loli.net/2020/03/09/kO6mEDMsIhtvqGe.jpg" alt="5.JPG"></p><p>这样我们就通过 服务消费者的 Feign客户端 取到了服务提供者 给予的接口数据。</p><blockquote><p>上面这就是声明式客户端 Feign的一种使用姿势，也是常用的手法，常见于很多Demo</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最近学习Spring Cloud Feign让我记忆颇深。本文记录一下声明式客户端 Feign的一种简单使用姿势。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://jianmin-xie.github.io/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://jianmin-xie.github.io/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="https://jianmin-xie.github.io/tags/SpringCloud/"/>
    
      <category term="feign" scheme="https://jianmin-xie.github.io/tags/feign/"/>
    
      <category term="Spring" scheme="https://jianmin-xie.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
